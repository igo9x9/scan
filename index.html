<!doctype html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="description" content="本物の碁盤の写真、囲碁ソフトのスクショなどから、碁石を認識してSGF形式のデータを作るためのツール">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@igo9x9" />
    <meta property="og:url" content="https://igo9x9.github.io/scan/" />
    <meta property="og:title" content="碁石拾い" />
    <meta property="og:description" content="碁盤画像からSGF形式のデータを作るためのツール" />
    <meta property="og:image" content="https://igo9x9.github.io/scan/twitterimg.png" />
    <title>碁石拾い</title>
    <link rel="icon" href="favicon.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css">
    <script src="https://misohena.github.io/js_igo/igo.js?ver=20200514"></script>
    <script src="https://misohena.github.io/js_igo/igo_view.js?ver=20200514"></script>
    <style>
        .canvas-wrapper {
            position: relative;
        }
        .canvas-wrapper canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        .button-success {
            background: rgb(28, 184, 65);
            color: white;
        }
        .pure-button {
            border-radius: 4px;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
            width: 100%;
        }
        .hide {
            display: none;
        }
        .text-shadow {
            text-shadow:
            1px 1px 0px #000, -1px -1px 0px #000,
            -1px 1px 0px #000,  1px -1px 0px #000,
            1px 0px 0px #000, -1px  0px 0px #000,
            0px 1px 0px #000,  0px -1px 0px #000;
        }
    </style>
</head>

<div style="max-width: 330px;margin-left:auto;margin-right:auto;">
    <div style="text-align: center;font-size: 0.8rem;padding-top: 20px;padding-bottom: 5px;">碁盤画像からSGFデータを作る</div>
    <div style="text-align: center;font-size: 1.5rem;">碁石拾い</div>

    <p>
        本物の碁盤の写真、囲碁ソフトのスクショなどから、SGF形式のデータを作るためのツールです。
    </p>
    <p>
        碁盤の画像を選択した後、緑色の丸<span style="color:green" class="text-shadow">●</span>を動かして、四隅にピッタリ合うように調節してください。スキャンボタンを押すと、認識した黒石には黄色の点<span style="color:yellow" class="text-shadow">●</span>、白石には赤色の点<span style="color:red" class="text-shadow">●</span>が付きますので、すべての碁石が認識されるまで、緑の丸を調節して「スキャン」を繰り返します。
    </p>
    
    <hr style="margin-top:20px;margin-bottom: 20px;">

    <div style="text-align:center;margin-bottom:20px;">
        <input type="file" id="file">
    </div>
    
    <div style="text-align:center">
        <canvas id="canvas1" width="320" height="320" style="border: 1px solid #000"></canvas>
    </div>
    
    <div style="text-align:center;margin-top: -327px;">
        <canvas id="canvas2" width="320" height="320" style="border: 1px solid #000"></canvas>
    </div>
    
    <div style="text-align:center;">
        <canvas id="rect" width="320" height="320" style="border: 1px solid #000;"></canvas>
    </div>
    
    <div style="text-align:center; margin-top: 20px;">
        <button id="scan" class="button-success pure-button">スキャン</button>
    </div>
    
    <div style="text-align:center; margin-top: 20px;">
    
        <div id="js-igo"></div>
    
    </div>
    
    <div style="text-align:center; margin-top: 20px;" class="hide" id="copy-wrapper">
        <button id="copy" class="pure-button-primary pure-button">SGF形式をクリップボードにコピー</button>
    </div>
    
    <div style="text-align:center; margin-top: 20px;margin-bottom: 50px;" class="hide" id="fujigoban-wrapper">
        <a id="fujigoban" href="https://fujigoban.appspot.com/ai/" class="pure-button-primary pure-button" target="_blank">AIの評価を見る（藤碁盤様のHPへ）</a>
    </div>
    
    <div style="text-align:center; margin-top: 40px;margin-bottom: 20px;font-size: 0.8rem;">
        ando19721226@gmail.com
    </div>

</div>


<script>

document.getElementById("copy").addEventListener("click", function() {
    navigator.clipboard.writeText(jsIgoGameView.model.toSGF());
    alert("SGF形式のデータをクリップボードにコピーしました。\n別の囲碁ソフトに貼り付けて使えます。");
});

let gobanSize = 19;

const canvas1 = document.getElementById('canvas1');
const ctx1 = canvas1.getContext('2d');

const canvas2 = document.getElementById('canvas2');
const ctx2 = canvas2.getContext('2d');

const image = new Image();

let cur_tp = -1;
let drawFlag = false;
let curx, cury;
let sabunX, sabunY;

document.getElementById("file").addEventListener("change", e => {

    const file = e.target.files[0];
    const reader = new FileReader();
    reader.readAsDataURL(file);

    if (file) {
        reader.onload = () => {
            image.src = reader.result;
        }
    }
});

canvas2.addEventListener("mousemove", function(e) {

    if (!drawFlag) return;

    setxy(e, 0);

    if ( cur_tp !=- 1 ) {
        dt[cur_tp][0] = curx + sabunX;
        dt[cur_tp][1] = cury + sabunY;
        drawGrid();
    } else {
        imgX = curx + sabunX;
        imgY = cury + sabunY;
        update();
    }

}, true);

canvas2.addEventListener("mousedown", function(e) {
    drawFlag = true;
    setxy(e, 0);
    checkStartPoint(curx, cury);
    if (cur_tp != -1) {
        drawGrid();
    }
}, true);

canvas2.addEventListener("mousewheel", function(e) {
    e.preventDefault();
    if (e.wheelDelta > 0) {
        imgScale += 0.001;
        update();
    } else {
        imgScale -= 0.001;
        update();
    }
}, true);

canvas2.addEventListener("touchmove", function(e) {

    if (!drawFlag) return;

    setxy(e, 1) ;

    if (event.touches.length === 2) {
        let distance = getDistance(event.touches[0], event.touches[1]);
        // imgScale = scaleAtTouchStart * (distance / distanceWhenTouched);
        if (distance > distanceWhenTouched) {
            imgScale += 0.0001;
        } else if (distance < distanceWhenTouched) {
            imgScale -= 0.0001;
        }
        update();
    } else if (cur_tp !=- 1) {
        dt[cur_tp][0] = curx + sabunX;
        dt[cur_tp][1] = cury + sabunY;
        drawGrid();
    } else {
        imgX = curx + sabunX;
        imgY = cury + sabunY;
        update();
    }

}, true);

let scaleAtTouchStart;
let distanceWhenTouched;

canvas2.addEventListener("touchstart", function(e) {
    drawFlag = true;
    setxy(e, 1) ;
    checkStartPoint(curx, cury) ;

    if (e.touches.length === 2) {
        distanceWhenTouched = getDistance(e.touches[0], e.touches[1]);
        scaleAtTouchStart = imgScale;
    } else if (cur_tp != -1) {
        drawGrid();
    }
}, true);

// 2点間の距離を計算する関数
function getDistance(touch1, touch2) {
    const dx = touch1.clientX - touch2.clientX;
    const dy = touch1.clientY - touch2.clientY;
    return Math.sqrt(dx * dx + dy * dy);
}

canvas2.addEventListener("touchend", function(e) {
    drawGrid();
    drawFlag = false;
    cur_tp = -1;
}, true);

canvas2.addEventListener("mouseup", function(e) {
    drawGrid();
    drawFlag = false;
    cur_tp = -1;
}, true);

const dt = [[10, 10], [10, 320 - 10], [320 - 10, 320 - 10], [320 - 10, 10]] ;

function setxy(e, f) {

    e.preventDefault(); 

    rect = e.target.getBoundingClientRect() ;

    if ( f == 0 ) {
        curx = e.clientX;
        cury = e.clientY;
    } else {
        t = e.touches[0];
        curx = t.pageX - window.pageXOffset;
        cury = t.pageY  - window.pageYOffset;
    }
    curx  = curx - rect.left ;       
    cury  = cury - rect.top ;

}

function drawGrid() {

    ctx2.clearRect(0, 0, 1000, 1000);

    for ( i = 0 ; i < dt.length - 1 ; i++ ) {
        drawLine(ctx2, dt[i][0], dt[i][1], dt[i+1][0], dt[i+1][1], 1, "#0000ff");
    }

    drawLine(ctx2, dt[0][0], dt[0][1], dt[3][0], dt[3][1], 1, "#0000ff") ;

    for ( i = 0 ; i < dt.length ; i++ ) {
        drawCircle(ctx2, dt[i][0], dt[i][1], 5, "#00ff00");
    }

}

let sgfSetup = "";

function checkStartPoint(mx, my) {

    for ( i = 0 ; i < dt.length ; i++ ) {
        if ((dt[i][0] - 80 < mx && mx < dt[i][0] + 80) &&  (dt[i][1] - 80 < my && my < dt[i][1] + 80) ) { 
            cur_tp = i;
            sabunX = dt[i][0] - mx;
            sabunY = dt[i][1] - my;
            return true;
        } else {
            sabunX = imgX - mx;
            sabunY = imgY - my;
            cur_tp = -1;
        }
    }

    return false ; 
}

function drawCircle(ctx, x, y, r, c) {

    x = parseInt(x) ;
    y = parseInt(y) ;
    r = parseInt(r) ;

    ctx.beginPath();

    ctx.fillStyle = c;
    ctx.arc(x ,y ,r ,0, 2 * Math.PI, false) ;
    ctx.fill();

}

function drawLine(ctx, x1,y1,x2,y2,w,c) {
    x1 = parseInt(x1) ;
    y1 = parseInt(y1) ;
    x2 = parseInt(x2) ;
    y2 = parseInt(y2) ;
    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.strokeStyle = c ;
    ctx.lineWidth = w ;
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.closePath();
}


let imgScale = 1;
let imgX = 0, imgY = 0;

function update() {
    ctx1.clearRect(0, 0, 1000, 1000);
    ctx1.save();
    ctx1.scale(imgScale, imgScale);
    ctx1.drawImage(image, imgX, imgY);
    ctx1.restore();
}

// return "B" or "W" or ""
function getStoneColor(ctx, x, y) {

    const blackMax = 80;
    const whiteMin = 150;
    const distance = 3;

    const imagedata = ctx.getImageData(x, y, 1, 1);
    const r = imagedata.data[0];
    const g = imagedata.data[1];
    const b = imagedata.data[2];

    const imagedata1 = ctx.getImageData(x + distance, y + distance, 1, 1);
    const r1 = imagedata1.data[0];
    const g1 = imagedata1.data[1];
    const b1 = imagedata1.data[2];

    const imagedata2 = ctx.getImageData(x + distance, y - distance, 1, 1);
    const r2 = imagedata2.data[0];
    const g2 = imagedata2.data[1];
    const b2 = imagedata2.data[2];

    const imagedata3 = ctx.getImageData(x - distance, y + distance, 1, 1);
    const r3 = imagedata3.data[0];
    const g3 = imagedata3.data[1];
    const b3 = imagedata3.data[2];

    const imagedata4 = ctx.getImageData(x - distance, y - distance, 1, 1);
    const r4 = imagedata4.data[0];
    const g4 = imagedata4.data[1];
    const b4 = imagedata4.data[2];

    let isBlack = booleanToNumber(r < blackMax && g < blackMax && b < blackMax) +
        booleanToNumber(r1 < blackMax && g1 < blackMax && b1 < blackMax) +
        booleanToNumber(r2 < blackMax && g2 < blackMax && b2 < blackMax) +
        booleanToNumber(r3 < blackMax && g3 < blackMax && b3 < blackMax) +
        booleanToNumber(r4 < blackMax && g4 < blackMax && b4 < blackMax) >= 2 ? true : false;

    let isWhite = booleanToNumber(r > whiteMin && g > whiteMin && b > whiteMin) +
        booleanToNumber(r1 > whiteMin && g1 > whiteMin && b1 > whiteMin) +
        booleanToNumber(r2 > whiteMin && g2 > whiteMin && b2 > whiteMin) +
        booleanToNumber(r3 > whiteMin && g3 > whiteMin && b3 > whiteMin) +
        booleanToNumber(r4 > whiteMin && g4 > whiteMin && b4 > whiteMin) >= 2 ? true : false;

    // 黄色っぽい（青だけが低い）のなら碁盤の可能性が高い
    // if (isBlack && b1 < r1 - 10 && b1 < g1 - 10 && b2 < r2 - 10 && b2 < g2 - 10 && b3 < r3 - 10 && b3 < g3 - 10 && b4 < r4 - 10 && b4 < g4 - 10) {
    //     isBlack = false;
    // }
    // if (isWhite && b1 < r1 - 10 && b1 < g1 - 10 && b2 < r2 - 10 && b2 < g2 - 10 && b3 < r3 - 10 && b3 < g3 - 10 && b4 < r4 - 10 && b4 < g4 - 10) {
    //     isWhite = false;
    // }

    return isWhite ? "W" : (isBlack ? "B" : "");
}

function booleanToNumber(bool) {
    return bool ? 1 : 0;
}

let sgf;

document.getElementById("scan").addEventListener("click", e => {


    // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    const outputCanvas = document.getElementById("rect");
    const outputImage = trasformToRectangle(
        canvas1,
        new Point(dt[0][0], dt[0][1]),
        new Point(dt[3][0], dt[3][1]),
        new Point(dt[1][0], dt[1][1]),
        new Point(dt[2][0], dt[2][1]),
        outputCanvas
    );
    const outputCavasCtx = outputCanvas.getContext("2d");
    outputCavasCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
    outputCavasCtx.beginPath();
    outputCavasCtx.rect( 0, 0, outputCanvas.width, outputCanvas.height);
    outputCavasCtx.fillStyle = "#ecc656";
    outputCavasCtx.fill();
    outputCavasCtx.drawImage(outputImage, 10, 10)

    sgfSetup = "";
    const alphabet = 'abcdefghijklmnopqrstuvwxyz'.split("");

    let xx = 0;
    let yy = 0;

    let last_x = -1;
    let last_y = -1;

    for (let x = 10; x <= outputCanvas.width - 10; x += (outputCanvas.width - 20) / (gobanSize - 1)) {
        drawLine(outputCavasCtx, x, 10, x, outputCanvas.height - 10, 1, "#ecc656");
    }
    for (let y = 10; y <= outputCanvas.height - 10; y += (outputCanvas.height - 20) / (gobanSize - 1)) {
        drawLine(outputCavasCtx, 10, y, outputCanvas.width - 10, y, 1, "#ecc656");
    }

    for (let x = 10; x <= (outputCanvas.width - 10); x += (outputCanvas.width - 20) / (gobanSize - 1)) {
        for (let y = 10; y <= (outputCanvas.height - 10); y += (outputCanvas.height - 20) / (gobanSize - 1)) {
            const color = getStoneColor(outputCavasCtx, x, y);
            if (color === "B") {
                drawCircle(outputCavasCtx, x, y, 3, "yellow");
                sgfSetup += "AB[" + alphabet[xx] + alphabet[yy] + "]";
            } else if (color === "W") {
                drawCircle(outputCavasCtx, x, y, 3, "red");
                sgfSetup += "AW[" + alphabet[xx] + alphabet[yy] + "]";
            // } else {
            //     drawCircle(outputCavasCtx, x, y, 2, "gray");
            }
            yy += 1;
        }
        yy = 0;
        xx += 1;

    }


    // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    sgf = "(;FF[4]GM[1]SZ[" + gobanSize + "]";

    sgf += sgfSetup;
    sgf += ")";

    const parent = document.getElementById("js-igo");
    while (parent.firstChild) {
        parent.removeChild(parent.firstChild);
    }

    jsIgoGameView = new igo.GameView(
        "js-igo",
        sgf,
        {
            // ui:{bottom: ["UndoRedo"]},
            ui: {},
            editable: false,
        }
    );    
    jsIgoGameView.fitBoardSizeToWindowAndParent();

    document.getElementById("fujigoban").href = "https://fujigoban.appspot.com/ai/?sgf=" + jsIgoGameView.model.toSGF();
    document.getElementById("copy-wrapper").classList.remove("hide");
    document.getElementById("fujigoban-wrapper").classList.remove("hide");

    // window.scroll(0, document.documentElement.scrollHeight - document.documentElement.clientHeight);

});

let jsIgoGameView;

image.addEventListener("load",function (){
    // canvas.width = image.naturalWidth;
    // canvas.height = image.naturalHeight;

    imgScale = canvas1.width / image.naturalWidth;
    imgX = 0, imgY = 0;

    ctx1.save();
    ctx1.scale(imgScale, imgScale);
    ctx1.clearRect(0, 0, 1000, 1000);
    ctx1.drawImage(image, 0, 0);
    ctx1.restore();

    drawGrid();
});

image.src = "19x19.jpg";

canvas2.addEventListener("click", e => {
    const rect = e.target.getBoundingClientRect();

        // ブラウザ上での座標を求める
    const   viewX = e.clientX - rect.left,
            viewY = e.clientY - rect.top;

        // 表示サイズとキャンバスの実サイズの比率を求める
    const   scaleWidth =  canvas2.clientWidth / canvas2.width,
            scaleHeight =  canvas2.clientHeight / canvas2.height;

        // ブラウザ上でのクリック座標をキャンバス上に変換
    const   canvasX = Math.floor( viewX / scaleWidth ),
            canvasY = Math.floor( viewY / scaleHeight );

	const index = (canvasX * (canvasY - 1)) * 4;

  
    var imagedata = ctx1.getImageData(canvasX, canvasY, 1, 1);

    // RGBAの取得。
    var r = imagedata.data[0];
    var g = imagedata.data[1];
    var b = imagedata.data[2];
    var a = imagedata.data[3];

    console.log(canvasX, canvasY, r, g, b, a);
    
});




class Point {
  constructor(x, y) {
    this.x = x
    this.y = y
  }
}

function trasformToRectangle(image, tl, tr, bl, br, outputShape) {
  const canvas = document.createElement("canvas");
  canvas.width = outputShape.width - 20;
  canvas.height = outputShape.height - 20;
  const context = canvas.getContext("2d");
  const project = createProjection(tl, tr, bl, br);
  for (let i = 0; i < canvas.width; i++) {
    for (let j = 0; j < canvas.height; j++) {
      const point = project(
        new Point(i / canvas.width, j / canvas.height)
      )
      context.drawImage(image, point.x, point.y, 1, 1, i, j, 1, 1)
    }
  }
  return canvas
}

function createProjection(tl, tr, bl, br) {
  // 射影変換の係数を求める
  // http://kondolab.org/archive/2010/research/cadcgtext/ChapE/ChapE02.html
  const x2 = tr.x - tl.x
  const y2 = tr.y - tl.y
  const x3 = br.x - tl.x
  const y3 = br.y - tl.y
  const x4 = bl.x - tl.x
  const y4 = bl.y - tl.y

  const delta123 = x2 * y3 - x3 * y2
  const delta124 = x2 * y4 - x4 * y2
  const delta134 = x3 * y4 - x4 * y3
  const delta1234 = delta123 + delta134
  const delta234 = delta1234 - delta124

  const a1 = delta134 * x2
  const b1 = delta123 * x4
  const a2 = delta134 * y2
  const b2 = delta123 * y4
  const a0 = delta134 - delta234
  const b0 = delta123 - delta234
  const c0 = delta234
  return p =>
    new Point(
      (a1 * p.x + b1 * p.y) / (a0 * p.x + b0 * p.y + c0) + tl.x,
      (a2 * p.x + b2 * p.y) / (a0 * p.x + b0 * p.y + c0) + tl.y
    )
}


</script>

</html>

