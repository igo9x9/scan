<!doctype html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
</head>
  

<div>
    <p>canvas preview</p>
    <canvas id="canvasPreview" width="320" height="320" style="border: 1px solid #000"></canvas>
</div>

<button id="zoomin">拡大</button>
<button id="zoomout">縮小</button>

<button id="up">上</button>
<button id="down">下</button>
<button id="left">左</button>
<button id="right">右</button>

<hr>

<button id="scan">スキャン</button>

<pre id="result" style="font-family: monospace;"></pre>


<script>

let imgZoom = 0;
let imgX = 0, imgY = 0;

document.getElementById("zoomin").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgZoom += 1;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("zoomout").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgZoom -= 1;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("up").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgY -= 1;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("down").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgY += 1;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("left").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgX -= 1;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("right").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgX += 1;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

function update() {
    ctx.clearRect(0, 0, 1000, 1000);
    ctx.drawImage(image, imgX, imgY, image.naturalWidth + imgZoom, image.naturalHeight + imgZoom);
    drawGrid();
}

function update2() {
    ctx.clearRect(0, 0, 1000, 1000);
    ctx.drawImage(image, imgX, imgY, image.naturalWidth + imgZoom, image.naturalHeight + imgZoom);
}

function drawGrid() {
    ctx.lineWidth = 1.0;
    ctx.strokeStyle = "red";
    ctx.strokeRect(10, 10, 300, 300);

    const unitWidth = 280 / 17;
    const unitHeight = 280 / 17;

    for (y = 10; y <= 310; y += unitHeight) {

        for (x = 10; x <= 310; x += unitWidth) {
            var imagedata = ctx.getImageData(x, y, 1, 1);

            var r = imagedata.data[0];
            var g = imagedata.data[1];
            var b = imagedata.data[2];

            ctx.fillStyle = 'green';
            ctx.fillRect(x, y, 2, 2);
            
        }

    }

}

document.getElementById("scan").addEventListener("click", e => {
    update2();

    const unitWidth = 280 / 17;
    const unitHeight = 280 / 17;

    let hoge = "";
    for (y = 10; y <= 300; y += unitHeight) {
        let row = "";
        for (x = 10; x <= 300; x += unitWidth) {

            const imagedata1 = ctx.getImageData(x, y, 1, 1);
            const r1 = imagedata1.data[0];
            const g1 = imagedata1.data[1];
            const b1 = imagedata1.data[2];

            const imagedata2 = ctx.getImageData(x - 10, y - 10, 1, 1);
            const r2 = imagedata1.data[0];
            const g2 = imagedata1.data[1];
            const b2 = imagedata1.data[2];

            const imagedata3 = ctx.getImageData(x + 10, y + 10, 1, 1);
            const r3 = imagedata1.data[0];
            const g3 = imagedata1.data[1];
            const b3 = imagedata1.data[2];

            const isBlack = (r1 < 100 && g1 < 100 && b1 < 100) 
                && (r2 < 100 && g2 < 100 && b2 < 100)
                && (r3 < 100 && g3 < 100 && b3 < 100);

            const isWhite = (r1 > 200 && g1 > 200 && b1 > 200) 
                && (r2 > 200 && g2 > 200 && b2 > 200)
                && (r3 > 200 && g3 > 200 && b3 > 200);

            if (isBlack) {
                row += "●";
            } else if (isWhite) {
                row += "○";
            } else {
                row += "　";
            }
            
        }
        hoge += row + "\n";
    }
    console.log(hoge);

    document.getElementById("result").innerText = hoge;

    drawGrid();

});

const minColor   = { r: 108, g: 0, b: 0 };
const maxColor   = { r: 255, g: 255, b: 255 };

let media;
let canvas;
let ctx;


// canvas要素をつくる
canvas = document.getElementById('canvasPreview');

// コンテキストを取得する
ctx = canvas.getContext('2d');

const image = new Image();
image.addEventListener("load",function (){
    // canvas.width = image.naturalWidth;
    // canvas.height = image.naturalHeight;
    ctx.drawImage(image, 0, 0);
    drawGrid();

});
image.src = "goban.png"

canvas.addEventListener("click", e => {
    const rect = e.target.getBoundingClientRect();

        // ブラウザ上での座標を求める
    const   viewX = e.clientX - rect.left,
            viewY = e.clientY - rect.top;

        // 表示サイズとキャンバスの実サイズの比率を求める
    const   scaleWidth =  canvas.clientWidth / canvas.width,
            scaleHeight =  canvas.clientHeight / canvas.height;

        // ブラウザ上でのクリック座標をキャンバス上に変換
    const   canvasX = Math.floor( viewX / scaleWidth ),
            canvasY = Math.floor( viewY / scaleHeight );

	const index = (canvasX * (canvasY - 1)) * 4;

  
    var imagedata = ctx.getImageData(canvasX, canvasY, 1, 1);

// RGBAの取得。
var r = imagedata.data[0];
var g = imagedata.data[1];
var b = imagedata.data[2];
var a = imagedata.data[3];

console.log(r, g, b);

    
});



// canvasを1ピクセルずつ色を確認し、該当すれば色を変更する
function _changePixelColor() {
  // コンテキストからデータ取得
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data      = imageData.data; // rgba、1バイト×4のデータ

  // ここに現在のピクセル情報を入れていく
  const currentColor = {};

  // 1ピクセルずつ確認していく
  for(let i = 0, len = data.length; i < len; i += 4) {
    currentColor.r = data[i];
    currentColor.g = data[i + 1];
    currentColor.b = data[i + 2];

    // 指定したrgb内であれば黄色に変換する
    if(_checkTargetColor(currentColor, minColor, maxColor)) {
      data[i]     = 255;
      data[i + 1] = 255;
      data[i + 2] = 0;
      // data[i + 3] = 0; => アルファ値なので、0にすれば透明になる
    }
  }

  // ImageDataオブジェクトに、変更済みのRGBAデータ（変数data）を代入する
  imageData.data = data;

  // canvasに変更済みのImageDataオブジェクトを描画する
  ctx.putImageData(imageData, 0, 0);
};

// 色の判定用の関数（引数：現在のピクセルのrgb、指定色の最小値、指定色の最大値）
// 指定したrgb内であれば true を返す
function _checkTargetColor(current, min, max) {
  if(min.r > current.r || current.r > max.r) return;
  if(min.g > current.g || current.g > max.g) return;
  if(min.b > current.b || current.b > max.b) return;
  return true;
};

</script>

</html>

