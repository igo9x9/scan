<!doctype html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="description" content="本物の碁盤の写真、囲碁ソフトのスクショなどから、碁石を認識してSGF形式のデータを作るためのツール">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@igo9x9" />
    <meta property="og:url" content="https://igo9x9.github.io/scan/" />
    <meta property="og:title" content="碁石拾い" />
    <meta property="og:description" content="碁盤画像からSGF形式のデータを作るためのツール" />
    <meta property="og:image" content="https://igo9x9.github.io/scan/twitterimg.png" />
    <title>碁石拾い</title>
    <link rel="icon" href="favicon.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css">
    <script src="https://misohena.github.io/js_igo/igo.js?ver=20200514"></script>
    <script src="https://misohena.github.io/js_igo/igo_view.js?ver=20200514"></script>
    <style>
        .canvas-wrapper {
            position: relative;
        }
        .canvas-wrapper canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        .button-success {
            background: rgb(28, 184, 65);
            color: white;
        }
        .pure-button {
            border-radius: 4px;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
            width: 100%;
        }
        .hide {
            display: none;
        }
        .text-shadow {
            text-shadow:
            1px 1px 0px #000, -1px -1px 0px #000,
            -1px 1px 0px #000,  1px -1px 0px #000,
            1px 0px 0px #000, -1px  0px 0px #000,
            0px 1px 0px #000,  0px -1px 0px #000;
        }
    </style>
</head>

<div style="max-width: 330px;margin-left:auto;margin-right:auto;">
    <div style="text-align: center;font-size: 0.8rem;padding-top: 20px;padding-bottom: 5px;">碁盤画像からSGFデータを作る</div>
    <div style="text-align: center;font-size: 1.5rem;">碁石拾い</div>

    <p>
        本物の碁盤の写真、囲碁ソフトのスクショなどから、SGF形式のデータを作るためのツールです。
    </p>
    <p>
        碁盤の画像を選択した後、格子状のグリッドが碁盤の目にピッタリ合うように、四隅の赤い丸<span style="color:red" class="text-shadow">●</span>を動かして調節してください。認識に成功した碁石には黄色の点<span style="color:yellow" class="text-shadow">●</span>が付きますので、すべての碁石が認識されるまで調整します。最後にスキャンボタンを押して完了です。
    </p>
    <p>
        ただ、碁盤の写真の場合、真正面から撮影していること、盤面に光の反射が無いこと、などの条件を満たしていないと、なかなか上手に認識できません…。
    </p>
    
    <hr style="margin-top:20px;margin-bottom: 20px;">

    <div style="text-align:center;margin-bottom:20px;">
        <input type="file" id="file">
    </div>
    
    <div style="text-align:center">
        <canvas id="canvas1" width="320" height="320" style="border: 1px solid #000"></canvas>
    </div>
    
    <div style="text-align:center;margin-top: -327px;">
        <canvas id="canvas2" width="320" height="320" style="border: 1px solid #000"></canvas>
    </div>
    
    
    <div style="text-align:center; margin-top: 20px;">
        <button id="scan" class="button-success pure-button">スキャン</button>
    </div>
    
    <div style="text-align:center; margin-top: 20px;">
    
        <div id="js-igo"></div>
    
    </div>
    
    <div style="text-align:center; margin-top: 20px;" class="hide" id="copy-wrapper">
        <button id="copy" class="pure-button-primary pure-button">SGF形式をクリップボードにコピー</button>
    </div>
    
    <div style="text-align:center; margin-top: 20px;margin-bottom: 50px;" class="hide" id="fujigoban-wrapper">
        <a id="fujigoban" href="https://fujigoban.appspot.com/ai/" class="pure-button-primary pure-button" target="_blank">AIの評価を見る（藤碁盤様のHPへ）</a>
    </div>
    
    <div style="text-align:center; margin-top: 40px;margin-bottom: 20px;font-size: 0.8rem;">
        ando19721226@gmail.com
    </div>

</div>


<script>

document.getElementById("copy").addEventListener("click", function() {
    navigator.clipboard.writeText(jsIgoGameView.model.toSGF());
    alert("SGF形式のデータをクリップボードにコピーしました。\n別の囲碁ソフトに貼り付けて使えます。");
});

let gobanSize = 19;

const canvas1 = document.getElementById('canvas1');
const ctx1 = canvas1.getContext('2d');

const canvas2 = document.getElementById('canvas2');
const ctx2 = canvas2.getContext('2d');

const image = new Image();

let cur_tp = -1;
let drawFlag = false;
let curx, cury;
let sabunX, sabunY;

document.getElementById("file").addEventListener("change", e => {

    const file = e.target.files[0];
    const reader = new FileReader();
    reader.readAsDataURL(file);

    if (file) {
        reader.onload = () => {
            image.src = reader.result;
        }
    }
});

canvas2.addEventListener("mousemove", function(e) {

    if (!drawFlag) return;

    setxy(e, 0);

    if ( cur_tp !=- 1 ) {
        dt[cur_tp][0] = curx + sabunX;
        dt[cur_tp][1] = cury + sabunY;
        drawGrid();
    } else {
        imgX = curx + sabunX;
        imgY = cury + sabunY;
        update();
    }

}, true);

canvas2.addEventListener("mousedown", function(e) {
    drawFlag = true;
    setxy(e, 0);
    checkStartPoint(curx, cury);
    if (cur_tp != -1) {
        drawGrid();
    }
}, true);

canvas2.addEventListener("mousewheel", function(e) {
    e.preventDefault();
    if (e.wheelDelta > 0) {
        imgScale += 0.001;
        update();
    } else {
        imgScale -= 0.001;
        update();
    }
}, true);

canvas2.addEventListener("touchmove", function(e) {

    if (!drawFlag) return;

    setxy(e, 1) ;

    if (event.touches.length === 2) {
        let distance = getDistance(event.touches[0], event.touches[1]);
        // imgScale = scaleAtTouchStart * (distance / distanceWhenTouched);
        if (distance > distanceWhenTouched) {
            imgScale += 0.0001;
        } else if (distance < distanceWhenTouched) {
            imgScale -= 0.0001;
        }
        update();
    } else if (cur_tp !=- 1) {
        dt[cur_tp][0] = curx + sabunX;
        dt[cur_tp][1] = cury + sabunY;
        drawGrid();
    } else {
        imgX = curx + sabunX;
        imgY = cury + sabunY;
        update();
    }

}, true);

let scaleAtTouchStart;
let distanceWhenTouched;

canvas2.addEventListener("touchstart", function(e) {
    drawFlag = true;
    setxy(e, 1) ;
    checkStartPoint(curx, cury) ;

    if (e.touches.length === 2) {
        distanceWhenTouched = getDistance(e.touches[0], e.touches[1]);
        scaleAtTouchStart = imgScale;
    } else if (cur_tp != -1) {
        drawGrid();
    }
}, true);

// 2点間の距離を計算する関数
function getDistance(touch1, touch2) {
    const dx = touch1.clientX - touch2.clientX;
    const dy = touch1.clientY - touch2.clientY;
    return Math.sqrt(dx * dx + dy * dy);
}

canvas2.addEventListener("touchend", function(e) {
    drawGrid();
    drawFlag = false;
    cur_tp = -1;
}, true);

canvas2.addEventListener("mouseup", function(e) {
    drawGrid();
    drawFlag = false;
    cur_tp = -1;
}, true);

const dt = [[10, 10], [10, 320 - 10], [320 - 10, 320 - 10], [320 - 10, 10]] ;

function setxy(e, f) {

    e.preventDefault(); 

    rect = e.target.getBoundingClientRect() ;

    if ( f == 0 ) {
        curx = e.clientX;
        cury = e.clientY;
    } else {
        t = e.touches[0];
        curx = t.pageX - window.pageXOffset;
        cury = t.pageY  - window.pageYOffset;
    }
    curx  = curx - rect.left ;       
    cury  = cury - rect.top ;

}

function drawGrid() {

    ctx2.clearRect(0, 0, 1000, 1000);

    for ( i = 0 ; i < dt.length - 1 ; i++ ) {
        drawLine(dt[i][0], dt[i][1], dt[i+1][0], dt[i+1][1], 1, "#0000ff");
    }

    drawLine(dt[0][0], dt[0][1], dt[3][0], dt[3][1], 1, "#0000ff") ;

    for ( i = 0 ; i < dt.length ; i++ ) {
        drawCircle(dt[i][0], dt[i][1], 5, "#ff0000");
    }

    const pointsX1 = [];
    const pointsY1 = [];

    const stepX1 = (dt[3][0] - dt[0][0]) / (gobanSize - 1);
    const stepY1 = (dt[3][1] - dt[0][1]) / (gobanSize - 1);
    const stepX2 = (dt[2][0] - dt[1][0]) / (gobanSize - 1);
    const stepY2 = (dt[2][1] - dt[1][1]) / (gobanSize - 1);

    for (let index = 0; index <= (gobanSize - 1); index += 1) {
        const x1 = dt[0][0] + stepX1 * index;
        const y1 = dt[0][1] + stepY1 * index;
        drawCircle(x1, y1, 2, "gray");

        const x2 = dt[1][0] + stepX2 * index;
        const y2 = dt[1][1] + stepY2 * index;
        drawCircle(x2, y2, 2, "gray");

        drawLine(x1, y1, x2, y2, 1, "gray");
        pointsX1.push(x1);
        pointsX1.push(x2);
        pointsY1.push(y1);
        pointsY1.push(y2);
    }

    const pointsX2 = [];
    const pointsY2 = [];

    const stepX3 = (dt[1][0] - dt[0][0]) / (gobanSize - 1);
    const stepY3 = (dt[1][1] - dt[0][1]) / (gobanSize - 1);
    const stepX4 = (dt[2][0] - dt[3][0]) / (gobanSize - 1);
    const stepY4 = (dt[2][1] - dt[3][1]) / (gobanSize - 1);

    for (let index = 0; index <= (gobanSize - 1); index += 1) {
        const x1 = dt[0][0] + stepX3 * index;
        let y1 = dt[0][1] + stepY3 * index;
        const x2 = dt[3][0] + stepX4 * index;
        let y2 = dt[3][1] + stepY4 * index;

        if (gobanSize === 19 && (dt[0][0] - dt[1][0] > 5 || dt[2][0] - dt[3][0] > 5)) {
            console.log("aaa", gobanSize, dt[0][0] - dt[1][0], dt[2][0] - dt[3][0]);
            const y = trans3D(index, y1, y2);
            y1 = y.y1;
            y2 = y.y2;
        }

        drawCircle(x1, y1, 2, "gray");
        drawCircle(x2, y2, 2, "gray");

        drawLine(x1, y1, x2, y2, 1, "gray");
        pointsX2.push(x1);
        pointsX2.push(x2);
        pointsY2.push(y1);
        pointsY2.push(y2);
    }

    sgfSetup = "";
    const alphabet = 'abcdefghijklmnopqrstuvwxyz'.split("");


    for (let x = 0; x < pointsX1.length; x += 2) {
        for (let y = 0; y < pointsY1.length; y += 2) {
            const point = getIntersection(pointsX1[x], pointsY1[x], pointsX1[x + 1], pointsY1[x + 1],
            pointsX2[y], pointsY2[y], pointsX2[y + 1], pointsY2[y + 1]);
        
            const color = getStoneColor(point.x, point.y);
            if (color === "B") {
                drawCircle(point.x, point.y, 3, "yellow");
                sgfSetup += "AB[" + alphabet[x/2] + alphabet[y/2] + "]";
            } else if (color === "W") {
                drawCircle(point.x, point.y, 3, "yellow");
                sgfSetup += "AW[" + alphabet[x/2] + alphabet[y/2] + "]";
            // } else {
            //     drawCircle(point.x, point.y, 3, "yellow");
            }
        }
    }

}

function trans3D(index, y1, y2) {

    switch (index) {
        case 1:
        case 2:
        case 3:
            y1 -= 3;
            y2 -= 3;
            break;
        case 4:
        case 5:
        case 6:
            y1 -= 4;
            y2 -= 4;
            break;
        case 7:
        case 8:
        case 9:
            y1 -= 5;
            y2 -= 5;
            break;
        case 10:
        case 11:
        case 12:
            y1 -= 5;
            y2 -= 5;
            break;
        case 13:
        case 14:
            y1 -= 5;
            y2 -= 5;
            break;
        case 15:
            y1 -= 4;
            y2 -= 4;
            break;
    }

    return {y1: y1, y2: y2};

}

let sgfSetup = "";

function checkStartPoint(mx, my) {

    for ( i = 0 ; i < dt.length ; i++ ) {
        if ((dt[i][0] - 80 < mx && mx < dt[i][0] + 80) &&  (dt[i][1] - 80 < my && my < dt[i][1] + 80) ) { 
            cur_tp = i;
            sabunX = dt[i][0] - mx;
            sabunY = dt[i][1] - my;
            return true;
        } else {
            sabunX = imgX - mx;
            sabunY = imgY - my;
            cur_tp = -1;
        }
    }

    return false ; 
}

function drawCircle(x, y, r, c) {

    x = parseInt(x) ;
    y = parseInt(y) ;
    r = parseInt(r) ;

    ctx2.beginPath();

    ctx2.fillStyle = c;
    ctx2.arc(x ,y ,r ,0, 2 * Math.PI, false) ;
    ctx2.fill();

}

function drawLine(x1,y1,x2,y2,w,c) {  //直線の描画
    x1 = parseInt(x1) ;
    y1 = parseInt(y1) ;
    x2 = parseInt(x2) ;
    y2 = parseInt(y2) ;
    ctx2.globalAlpha = 1;
    ctx2.beginPath();
    ctx2.strokeStyle = c ;
    ctx2.lineWidth = w ;
    ctx2.moveTo( x1,y1 );
    ctx2.lineTo( x2,y2 );
    ctx2.stroke();
    ctx2.closePath();
}


let imgScale = 1;
let imgX = 0, imgY = 0;

function update() {
    ctx1.clearRect(0, 0, 1000, 1000);
    ctx1.save();
    ctx1.scale(imgScale, imgScale);
    ctx1.drawImage(image, imgX, imgY);
    ctx1.restore();
}

function getIntersection(xA, yA, xB, yB, xC, yC, xD, yD) {

    let a1 = yA - yB,
        a2 = yC - yD,
        b1 = xB - xA,
        b2 = xD - xC,
        c1 = xA * (yB - yA) - yA * (xB - xA),
        c2 = xC * (yD - yC) - yC * (xD - xC);

    if (a1 * b2 == a2 * b1)
        throw new Error("Invalid Coordinates");

    let result = {};
    result.x = (c2 * b1 - c1 * b2) / (a1 * b2 - a2 * b1);
    result.y = (c2 * a1 - c1 * a2) / (b1 * a2 - b2 * a1);

    return result;
}

// return "B" or "W" or ""
function getStoneColor(x, y) {

    const blackMax = 80;
    const whiteMin = 130;

    const imagedata = ctx1.getImageData(x, y, 1, 1);
    const r = imagedata.data[0];
    const g = imagedata.data[1];
    const b = imagedata.data[2];

    const imagedata1 = ctx1.getImageData(x + 3, y + 3, 1, 1);
    const r1 = imagedata1.data[0];
    const g1 = imagedata1.data[1];
    const b1 = imagedata1.data[2];

    const imagedata2 = ctx1.getImageData(x + 3, y - 3, 1, 1);
    const r2 = imagedata2.data[0];
    const g2 = imagedata2.data[1];
    const b2 = imagedata2.data[2];

    const imagedata3 = ctx1.getImageData(x - 3, y + 3, 1, 1);
    const r3 = imagedata3.data[0];
    const g3 = imagedata3.data[1];
    const b3 = imagedata3.data[2];

    const imagedata4 = ctx1.getImageData(x - 3, y - 3, 1, 1);
    const r4 = imagedata4.data[0];
    const g4 = imagedata4.data[1];
    const b4 = imagedata4.data[2];

    let isBlack = (r < blackMax && g < blackMax && b < blackMax)
        && ((r1 < blackMax && g1 < blackMax && b1 < blackMax) || (r2 < blackMax && g2 < blackMax && b2 < blackMax) || (r3 < blackMax && g3 < blackMax && b3 < blackMax) || (r4 < blackMax && g4 < blackMax && b4 < blackMax));

    let isWhite = (r > whiteMin && g > whiteMin && b > whiteMin)
        && ((r1 > whiteMin && g1 > whiteMin && b1 > whiteMin) || (r2 > whiteMin && g2 > whiteMin && b2 > whiteMin) || (r3 > whiteMin && g3 > whiteMin && b3 > whiteMin) || (r4 > whiteMin && g4 > whiteMin && b4 > whiteMin));

    // 黄色っぽい（青だけが低い）のなら碁盤の可能性が高い
    if (isBlack && b1 < r1 - 10 && b1 < g1 - 10 && b2 < r2 - 10 && b2 < g2 - 10 && b3 < r3 - 10 && b3 < g3 - 10 && b4 < r4 - 10 && b4 < g4 - 10) {
        isBlack = false;
    }
    if (isWhite && b1 < r1 - 10 && b1 < g1 - 10 && b2 < r2 - 10 && b2 < g2 - 10 && b3 < r3 - 10 && b3 < g3 - 10 && b4 < r4 - 10 && b4 < g4 - 10) {
        isWhite = false;
    }

    return isBlack ? "B" : (isWhite ? "W" : "");
}

let sgf;

document.getElementById("scan").addEventListener("click", e => {

    sgf = "(;FF[4]GM[1]SZ[" + gobanSize + "]";

    sgf += sgfSetup;
    sgf += ")";

    const parent = document.getElementById("js-igo");
    while (parent.firstChild) {
        parent.removeChild(parent.firstChild);
    }

    jsIgoGameView = new igo.GameView(
        "js-igo",
        sgf,
        {
            // ui:{bottom: ["UndoRedo"]},
            ui: {},
            editable: false,
        }
    );    
    jsIgoGameView.fitBoardSizeToWindowAndParent();

    document.getElementById("fujigoban").href = "https://fujigoban.appspot.com/ai/?sgf=" + jsIgoGameView.model.toSGF();
    document.getElementById("copy-wrapper").classList.remove("hide");
    document.getElementById("fujigoban-wrapper").classList.remove("hide");

    window.scroll(0, document.documentElement.scrollHeight - document.documentElement.clientHeight);
});

let jsIgoGameView;

image.addEventListener("load",function (){
    // canvas.width = image.naturalWidth;
    // canvas.height = image.naturalHeight;

    imgScale = canvas1.width / image.naturalWidth;
    imgX = 0, imgY = 0;

    ctx1.save();
    ctx1.scale(imgScale, imgScale);
    ctx1.clearRect(0, 0, 1000, 1000);
    ctx1.drawImage(image, 0, 0);
    ctx1.restore();

    drawGrid();
});

image.src = "19x19.jpg";

canvas2.addEventListener("click", e => {
    const rect = e.target.getBoundingClientRect();

        // ブラウザ上での座標を求める
    const   viewX = e.clientX - rect.left,
            viewY = e.clientY - rect.top;

        // 表示サイズとキャンバスの実サイズの比率を求める
    const   scaleWidth =  canvas2.clientWidth / canvas2.width,
            scaleHeight =  canvas2.clientHeight / canvas2.height;

        // ブラウザ上でのクリック座標をキャンバス上に変換
    const   canvasX = Math.floor( viewX / scaleWidth ),
            canvasY = Math.floor( viewY / scaleHeight );

	const index = (canvasX * (canvasY - 1)) * 4;

  
    var imagedata = ctx1.getImageData(canvasX, canvasY, 1, 1);

    // RGBAの取得。
    var r = imagedata.data[0];
    var g = imagedata.data[1];
    var b = imagedata.data[2];
    var a = imagedata.data[3];

    console.log(r, g, b, a);
    
});

</script>

</html>
