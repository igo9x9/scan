<!doctype html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <script src="glift_1_1_2.min.js"></script>
    <style>
        .canvas-wrapper {
            position: relative;
        }
        .canvas-wrapper canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
  


<!-- <div>
    <div class="canvas-wrapper">
        <canvas id="canvas1" width="320" height="320" style="border: 1px solid #000"></canvas>
        <canvas id="canvas2" width="320" height="320" style="border: 1px solid #000"></canvas>
    </div>
</div> -->

<div style="text-align:center">
    <canvas id="canvas1" width="320" height="320" style="border: 1px solid #000"></canvas>
</div>

<div style="text-align:center;margin-top: -328.667px;">
    <canvas id="canvas2" width="320" height="320" style="border: 1px solid #000"></canvas>
</div>

<div>

    <div style="text-align:center">
        <input type="file" id="file">
    </div>

    <div style="text-align:center; margin-top: 20px;">
        <button id="up">上</button>
    </div>
    <div style="text-align:center; margin-top: 10px;">
        <button id="left" style="margin-right: 10px;">左</button>
        <button id="right" style="margin-left: 10px;">右</button>
    </div>
    <div style="text-align:center; margin-top: 10px;">
        <button id="down">下</button>
    </div>

    <div style="text-align:center; margin-top: 20px;">
        <button id="zoomin">拡大</button>
        <button id="zoomout">縮小</button>
    </div>

    <hr>

    <div style="text-align:center; margin-top: 20px;">
        <button id="scan">スキャン</button>
    </div>

    <pre id="result" style="font-family: monospace;"></pre>

</div>

<div id="test" style="width: 300px; height: 300px"></div>


<script>

let imgScale = 1;
let imgX = 0, imgY = 0;

document.getElementById("file").addEventListener("change", e => {

    const file = e.target.files[0];
    const reader = new FileReader();
    reader.readAsDataURL(file);

    if (file) {
        reader.onload = () => {
            image.src = reader.result;
        }
    }
})

document.getElementById("zoomin").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgScale += 0.001;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("zoomout").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgScale -= 0.001;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("up").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgY -= 1;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("down").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgY += 1;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("left").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgX -= 1;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("right").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgX += 1;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

function update() {
    ctx1.clearRect(0, 0, 1000, 1000);
    ctx1.save();
    ctx1.scale(imgScale, imgScale);
    ctx1.drawImage(image, imgX, imgY);
    ctx1.restore();
}


document.getElementById("scan").addEventListener("click", e => {
    update();

    const unitWidth = 280 / 17;
    const unitHeight = 280 / 17;

    const alphabet = 'abcdefghijklmnopqrstuvwxyz'.split("");
    let hoge = "";
    // let sgf = "(;FF[4]GM[1]SZ[19];";
    let sgf = "(;";

    let yy = 0;
    for (y = 11; y <= 300; y += unitHeight) {
        let row = "";
        let xx = 0;
        for (x = 11; x <= 300; x += unitWidth) {

            const imagedata1 = ctx1.getImageData(x, y, 1, 1);
            const r1 = imagedata1.data[0];
            const g1 = imagedata1.data[1];
            const b1 = imagedata1.data[2];

            const imagedata2 = ctx1.getImageData(x - 2, y - 2, 1, 1);
            const r2 = imagedata2.data[0];
            const g2 = imagedata2.data[1];
            const b2 = imagedata2.data[2];

            const imagedata3 = ctx1.getImageData(x + 2, y + 2, 1, 1);
            const r3 = imagedata3.data[0];
            const g3 = imagedata3.data[1];
            const b3 = imagedata3.data[2];

            const isBlack = (r1 < 80 && g1 < 80 && b1 < 80) 
                && (r2 < 80 && g2 < 80 && b2 < 80)
                && (r3 < 80 && g3 < 80 && b3 < 80);

            const isWhite = (r1 > 200 && g1 > 200 && b1 > 200) 
                && (r2 > 200 && g2 > 200 && b2 > 200)
                && (r3 > 200 && g3 > 200 && b3 > 200);

            if (isBlack) {
                row += "●";
                sgf += "AB[" + alphabet[xx] + alphabet[yy] + "]";
            } else if (isWhite) {
                row += "○";
                sgf += "AW[" + alphabet[xx] + alphabet[yy] + "]";
            } else {
                row += "　";
            }

            xx += 1;
            
        }

        yy += 1;
        hoge += row + "\n";
    }
    sgf += ")";

    document.getElementById("result").innerText = sgf;

    drawGrid();

    gliftWidget = glift.create({
        sgf: {
            sgfString: sgf,
            widgetType: 'EXAMPLE',
        },
        divId: "test"
    });
});


const canvas1 = document.getElementById('canvas1');
const ctx1 = canvas1.getContext('2d');

const canvas2 = document.getElementById('canvas2');
const ctx2 = canvas2.getContext('2d');

const image = new Image();

image.addEventListener("load",function (){
    // canvas.width = image.naturalWidth;
    // canvas.height = image.naturalHeight;

    imgScale = canvas1.height / image.naturalHeight;
    ctx1.save();
    ctx1.scale(imgScale, imgScale);
    ctx1.clearRect(0, 0, 1000, 1000);
    ctx1.drawImage(image, 0, 0);
    ctx1.restore();

    drawGrid();
});

image.src = "goban.png";

drawGrid();

function drawGrid() {
    ctx2.lineWidth = 1.0;
    ctx2.strokeStyle = "red";
    ctx2.strokeRect(10, 10, 300, 300);

    const unitWidth = 280 / 17;
    const unitHeight = 280 / 17;

    for (y = 11; y <= 310; y += unitHeight) {

        for (x = 11; x <= 310; x += unitWidth) {
            ctx2.beginPath();
            ctx2.fillStyle = 'green';
            ctx2.arc(x, y, 1, 0, Math.PI * 2, true);
            ctx2.fill();
        }

    }

}

// canvas.addEventListener("click", e => {
//     const rect = e.target.getBoundingClientRect();

//         // ブラウザ上での座標を求める
//     const   viewX = e.clientX - rect.left,
//             viewY = e.clientY - rect.top;

//         // 表示サイズとキャンバスの実サイズの比率を求める
//     const   scaleWidth =  canvas.clientWidth / canvas.width,
//             scaleHeight =  canvas.clientHeight / canvas.height;

//         // ブラウザ上でのクリック座標をキャンバス上に変換
//     const   canvasX = Math.floor( viewX / scaleWidth ),
//             canvasY = Math.floor( viewY / scaleHeight );

// 	const index = (canvasX * (canvasY - 1)) * 4;

  
//     var imagedata = ctx.getImageData(canvasX, canvasY, 1, 1);

// // RGBAの取得。
// var r = imagedata.data[0];
// var g = imagedata.data[1];
// var b = imagedata.data[2];
// var a = imagedata.data[3];

// console.log(r, g, b);

    
// });



// // canvasを1ピクセルずつ色を確認し、該当すれば色を変更する
// function _changePixelColor() {
//   // コンテキストからデータ取得
//   const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
//   const data      = imageData.data; // rgba、1バイト×4のデータ

//   // ここに現在のピクセル情報を入れていく
//   const currentColor = {};

//   // 1ピクセルずつ確認していく
//   for(let i = 0, len = data.length; i < len; i += 4) {
//     currentColor.r = data[i];
//     currentColor.g = data[i + 1];
//     currentColor.b = data[i + 2];

//     // 指定したrgb内であれば黄色に変換する
//     if(_checkTargetColor(currentColor, minColor, maxColor)) {
//       data[i]     = 255;
//       data[i + 1] = 255;
//       data[i + 2] = 0;
//       // data[i + 3] = 0; => アルファ値なので、0にすれば透明になる
//     }
//   }

//   // ImageDataオブジェクトに、変更済みのRGBAデータ（変数data）を代入する
//   imageData.data = data;

//   // canvasに変更済みのImageDataオブジェクトを描画する
//   ctx.putImageData(imageData, 0, 0);
// };

// // 色の判定用の関数（引数：現在のピクセルのrgb、指定色の最小値、指定色の最大値）
// // 指定したrgb内であれば true を返す
// function _checkTargetColor(current, min, max) {
//   if(min.r > current.r || current.r > max.r) return;
//   if(min.g > current.g || current.g > max.g) return;
//   if(min.b > current.b || current.b > max.b) return;
//   return true;
// };


</script>

</html>

