<!doctype html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css">
    <script src="https://misohena.github.io/js_igo/igo.js?ver=20200514"></script>
    <script src="https://misohena.github.io/js_igo/igo_view.js?ver=20200514"></script>
    <style>
        .canvas-wrapper {
            position: relative;
        }
        .canvas-wrapper canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        .button-success {
            background: rgb(28, 184, 65);
            color: white;
            border-radius: 4px;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);            
        }
    </style>
</head>

<div style="text-align: center;font-size: 1.3rem;padding: 20px;">碁盤画像を読み取る実験</div>

<div style="text-align:center;margin-bottom:20px;">
    <form class="pure-form" style="width: 320px;margin-left:auto;margin-right:auto;">
        <div class="pure-g">
            <div class="pure-u-1-3">
                <label for="radio-9" class="pure-radio">
                    <input type="radio" id="radio-9" name="ban-size" value="9" checked="" /> 9路
                </label>
            </div>
            <div class="pure-u-1-3">
                <label for="radio-13" class="pure-radio">
                    <input type="radio" id="radio-13" name="ban-size" value="13" /> 13路
                </label>
            </div>
            <div class="pure-u-1-3">
                <label for="radio-19" class="pure-radio">
                    <input type="radio" id="radio-19" name="ban-size" value="19" /> 19路
                </label>
            </div>
        </div>
    </form>
</div>

<div style="text-align:center;margin-bottom:20px;">
    <input type="file" id="file">
</div>

<div style="text-align:center">
    <canvas id="canvas1" width="320" height="320" style="border: 1px solid #000"></canvas>
</div>

<div style="text-align:center;margin-top: -327px;">
    <canvas id="canvas2" width="320" height="320" style="border: 1px solid #000"></canvas>
</div>

<div>
    <div class="pure-g" style="width: 320px;margin-left:auto;margin-right: auto;margin-top: 40px;">
        <div class="pure-u-1-2">
            <div style="text-align:center;">
                <button id="up" class="pure-button pure-button-primary">上</button>
            </div>
            <div style="text-align:center; margin-top: 20px;">
                <button id="left" class="pure-button pure-button-primary" style="margin-right: 20px;">左</button>
                <button id="right" class="pure-button pure-button-primary" style="margin-left: 20px;">右</button>
            </div>
            <div style="text-align:center; margin-top: 20px;">
                <button id="down" class="pure-button pure-button-primary">下</button>
            </div>
        </div>
        <div class="pure-u-1-2">
            <div style="text-align:center; margin-top: 30px;">
                <button id="zoomin" class="pure-button pure-button-primary">拡大</button>
                <br>
                <button id="zoomout" class="pure-button pure-button-primary" style="margin-top:20px;">縮小</button>
            </div>
        </div>
    </div>
</div>




<div style="text-align:center; margin-top: 40px;">
    <button id="scan" class="button-success pure-button">スキャン</button>
</div>

<div style="text-align:center; margin-top: 20px;">

    <div id="js-igo"></div>

    <div style="text-align:center; margin-top: 10px;">
        SGFデータ
    </div>
    <textarea id="result" style="width:100%;" rows="5"></textarea>
    
</div>

<a href="https://fujigoban.appspot.com/ai/">AIを使う</a>

<script>

let radio_btns = document.querySelectorAll(`input[type='radio'][name='ban-size']`);

for (let target of radio_btns) {
	target.addEventListener(`change`, function () {
        gobanSize = Number(target.value);
        drawGrid();
    });
}

let gobanSize = 9;

const canvas1 = document.getElementById('canvas1');
const ctx1 = canvas1.getContext('2d');

const canvas2 = document.getElementById('canvas2');
const ctx2 = canvas2.getContext('2d');

const image = new Image();

let cur_tp = -1;
let drawFlag = false;
let curx, cury;
let sabunX, sabunY;

canvas2.addEventListener("mousemove", function(e) {
    setxy(e, 0);

    if ( cur_tp !=- 1 ) {
        dt[cur_tp][0] = curx + sabunX;
        dt[cur_tp][1] = cury + sabunY;
        drawGrid();
    }
}, true);

canvas2.addEventListener("mousedown", function(e) {
    drawFlag = true;
    setxy(e, 0);
    checkStartPoint(curx, cury);
    if (cur_tp != -1) {
        drawGrid();
    }
}, true);

canvas2.addEventListener("touchmove", function(e) {
    setxy(e, 1) ;
    if (cur_tp !=- 1) {
        dt[cur_tp][0] = curx + sabunX;
        dt[cur_tp][1] = cury + sabunY;
        drawGrid();
    }
}, true);

canvas2.addEventListener("touchstart", function(e) {
    drawFlag = true;
    setxy(e, 1) ;
    checkStartPoint(curx, cury) ;
    if (cur_tp != -1) {
        drawGrid();
    }
}, true);

canvas2.addEventListener("touchend", function(e) {
    drawGrid();
    drawFlag = false;
    cur_tp = -1;
}, true);

canvas2.addEventListener("mouseup", function(e) {
    drawGrid();
    drawFlag = false;
    cur_tp = -1;
}, true);

const dt = [[10, 10], [10, 320 - 10], [320 - 10, 320 - 10], [320 - 10, 10]] ;

function setxy(e, f) {

    e.preventDefault(); 

    rect = e.target.getBoundingClientRect() ;

    if ( f == 0 ) {
        curx = e.clientX;
        cury = e.clientY;
    } else {
        t = e.touches[0];
        curx = t.pageX - window.pageXOffset;
        cury = t.pageY  - window.pageYOffset;
    }
    curx  = curx - rect.left ;       
    cury  = cury - rect.top ;

}

function drawGrid() {

    ctx2.clearRect(0, 0, 1000, 1000);

    for ( i = 0 ; i < dt.length - 1 ; i++ ) {
        drawLine(dt[i][0], dt[i][1], dt[i+1][0], dt[i+1][1], 1, "#0000ff");
    }

    drawLine(dt[0][0], dt[0][1], dt[3][0], dt[3][1], 1, "#0000ff") ;

    for ( i = 0 ; i < dt.length ; i++ ) {
        drawCircle(dt[i][0], dt[i][1], 5, "#ff0000");
    }

    const pointsX1 = [];
    const pointsY1 = [];

    const stepX1 = (dt[3][0] - dt[0][0]) / (gobanSize - 1);
    const stepY1 = (dt[3][1] - dt[0][1]) / (gobanSize - 1);
    const stepX2 = (dt[2][0] - dt[1][0]) / (gobanSize - 1);
    const stepY2 = (dt[2][1] - dt[1][1]) / (gobanSize - 1);

    for (let index = 0; index <= (gobanSize - 1); index += 1) {
        const x1 = dt[0][0] + stepX1 * index;
        const y1 = dt[0][1] + stepY1 * index;
        drawCircle(x1, y1, 2, "gray");

        const x2 = dt[1][0] + stepX2 * index;
        const y2 = dt[1][1] + stepY2 * index;
        drawCircle(x2, y2, 2, "gray");

        drawLine(x1, y1, x2, y2, 1, "gray");
        pointsX1.push(x1);
        pointsX1.push(x2);
        pointsY1.push(y1);
        pointsY1.push(y2);
    }

    const pointsX2 = [];
    const pointsY2 = [];

    const stepX3 = (dt[1][0] - dt[0][0]) / (gobanSize - 1);
    const stepY3 = (dt[1][1] - dt[0][1]) / (gobanSize - 1);
    const stepX4 = (dt[2][0] - dt[3][0]) / (gobanSize - 1);
    const stepY4 = (dt[2][1] - dt[3][1]) / (gobanSize - 1);

    for (let index = 0; index <= (gobanSize - 1); index += 1) {
        const x1 = dt[0][0] + stepX3 * index;
        let y1 = dt[0][1] + stepY3 * index;
        const x2 = dt[3][0] + stepX4 * index;
        let y2 = dt[3][1] + stepY4 * index;

        if (gobanSize === 19 && (dt[0][0] - dt[1][0] > 5 || dt[2][0] - dt[3][0] > 5)) {
            console.log("aaa", gobanSize, dt[0][0] - dt[1][0], dt[2][0] - dt[3][0]);
            const y = trans3D(index, y1, y2);
            y1 = y.y1;
            y2 = y.y2;
        }

        drawCircle(x1, y1, 2, "gray");
        drawCircle(x2, y2, 2, "gray");

        drawLine(x1, y1, x2, y2, 1, "gray");
        pointsX2.push(x1);
        pointsX2.push(x2);
        pointsY2.push(y1);
        pointsY2.push(y2);
    }

    sgfSetup = "";
    const alphabet = 'abcdefghijklmnopqrstuvwxyz'.split("");


    for (let x = 0; x < pointsX1.length; x += 2) {
        for (let y = 0; y < pointsY1.length; y += 2) {
            const point = getIntersection(pointsX1[x], pointsY1[x], pointsX1[x + 1], pointsY1[x + 1],
            pointsX2[y], pointsY2[y], pointsX2[y + 1], pointsY2[y + 1]);
        
            const color = getStoneColor(point.x, point.y);
            if (color === "B") {
                drawCircle(point.x, point.y, 3, "yellow");
                sgfSetup += "AB[" + alphabet[x/2] + alphabet[y/2] + "]";
            } else if (color === "W") {
                drawCircle(point.x, point.y, 3, "yellow");
                sgfSetup += "AW[" + alphabet[x/2] + alphabet[y/2] + "]";
            // } else {
            //     drawCircle(point.x, point.y, 3, "yellow");
            }
        }
    }

}

function trans3D(index, y1, y2) {

    switch (index) {
        case 1:
        case 2:
        case 3:
            y1 -= 3;
            y2 -= 3;
            break;
        case 4:
        case 5:
        case 6:
            y1 -= 4;
            y2 -= 4;
            break;
        case 7:
        case 8:
        case 9:
            y1 -= 5;
            y2 -= 5;
            break;
        case 10:
        case 11:
        case 12:
            y1 -= 5;
            y2 -= 5;
            break;
        case 13:
        case 14:
            y1 -= 5;
            y2 -= 5;
            break;
        case 15:
            y1 -= 4;
            y2 -= 4;
            break;
    }

    return {y1: y1, y2: y2};

}

let sgfSetup = "";

function checkStartPoint(mx, my) {

    for ( i = 0 ; i < dt.length ; i++ ) {
        if ((dt[i][0] - 100 < mx && mx < dt[i][0] + 100) &&  (dt[i][1] - 100 < my && my < dt[i][1] + 100) ) { 
            cur_tp = i;
            sabunX = dt[i][0] - mx;
            sabunY = dt[i][1] - my;
            return true;
        } else {
            cur_tp = -1;
        }
    }

    return false ; 
}

function drawCircle(x, y, r, c) {

    x = parseInt(x) ;
    y = parseInt(y) ;
    r = parseInt(r) ;

    ctx2.beginPath();

    ctx2.fillStyle = c;
    ctx2.arc(x ,y ,r ,0, 2 * Math.PI, false) ;
    ctx2.fill();

}

function drawLine(x1,y1,x2,y2,w,c) {  //直線の描画
    x1 = parseInt(x1) ;
    y1 = parseInt(y1) ;
    x2 = parseInt(x2) ;
    y2 = parseInt(y2) ;
    ctx2.globalAlpha = 1;
    ctx2.beginPath();
    ctx2.strokeStyle = c ;
    ctx2.lineWidth = w ;
    ctx2.moveTo( x1,y1 );
    ctx2.lineTo( x2,y2 );
    ctx2.stroke();
    ctx2.closePath();
}


let imgScale = 1;
let imgX = 0, imgY = 0;

document.getElementById("file").addEventListener("change", e => {

    const file = e.target.files[0];
    const reader = new FileReader();
    reader.readAsDataURL(file);

    if (file) {
        reader.onload = () => {
            image.src = reader.result;
        }
    }
})

document.getElementById("zoomin").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgScale += 0.001;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("zoomout").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgScale -= 0.001;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("up").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgY -= 5;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("down").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgY += 5;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("left").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgX -= 5;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

document.getElementById("right").addEventListener("pointerdown", e => {
    const intervalId = setInterval(() => {
        imgX += 5;
        update();
    }, 50);
    document.addEventListener('pointerup', () => {        
        clearInterval(intervalId)
    }, { once: true })  
});

function update() {
    ctx1.clearRect(0, 0, 1000, 1000);
    ctx1.save();
    ctx1.scale(imgScale, imgScale);
    ctx1.drawImage(image, imgX, imgY);
    ctx1.restore();
}

function getIntersection(xA, yA, xB, yB, xC, yC, xD, yD) {

    let a1 = yA - yB,
        a2 = yC - yD,
        b1 = xB - xA,
        b2 = xD - xC,
        c1 = xA * (yB - yA) - yA * (xB - xA),
        c2 = xC * (yD - yC) - yC * (xD - xC);

    if (a1 * b2 == a2 * b1)
        throw new Error("Invalid Coordinates");

    let result = {};
    result.x = (c2 * b1 - c1 * b2) / (a1 * b2 - a2 * b1);
    result.y = (c2 * a1 - c1 * a2) / (b1 * a2 - b2 * a1);

    return result;
}

// return "B" or "W" or ""
function getStoneColor(x, y) {

    const blackMax = 80;
    const whiteMin = 130;

    const imagedata = ctx1.getImageData(x, y, 1, 1);
    const r = imagedata.data[0];
    const g = imagedata.data[1];
    const b = imagedata.data[2];

    const imagedata1 = ctx1.getImageData(x + 3, y + 3, 1, 1);
    const r1 = imagedata1.data[0];
    const g1 = imagedata1.data[1];
    const b1 = imagedata1.data[2];

    const imagedata2 = ctx1.getImageData(x + 3, y - 3, 1, 1);
    const r2 = imagedata2.data[0];
    const g2 = imagedata2.data[1];
    const b2 = imagedata2.data[2];

    const imagedata3 = ctx1.getImageData(x - 3, y + 3, 1, 1);
    const r3 = imagedata3.data[0];
    const g3 = imagedata3.data[1];
    const b3 = imagedata3.data[2];

    const imagedata4 = ctx1.getImageData(x - 3, y - 3, 1, 1);
    const r4 = imagedata4.data[0];
    const g4 = imagedata4.data[1];
    const b4 = imagedata4.data[2];

    let isBlack = (r < blackMax && g < blackMax && b < blackMax)
        && ((r1 < blackMax && g1 < blackMax && b1 < blackMax) || (r2 < blackMax && g2 < blackMax && b2 < blackMax) || (r3 < blackMax && g3 < blackMax && b3 < blackMax) || (r4 < blackMax && g4 < blackMax && b4 < blackMax));

    let isWhite = (r > whiteMin && g > whiteMin && b > whiteMin)
        && ((r1 > whiteMin && g1 > whiteMin && b1 > whiteMin) || (r2 > whiteMin && g2 > whiteMin && b2 > whiteMin) || (r3 > whiteMin && g3 > whiteMin && b3 > whiteMin) || (r4 > whiteMin && g4 > whiteMin && b4 > whiteMin));

    // 黄色っぽい（青だけが低い）のなら碁盤の可能性が高い
    if (isBlack && b1 < r1 - 10 && b1 < g1 - 10 && b2 < r2 - 10 && b2 < g2 - 10 && b3 < r3 - 10 && b3 < g3 - 10 && b4 < r4 - 10 && b4 < g4 - 10) {
        isBlack = false;
    }
    if (isWhite && b1 < r1 - 10 && b1 < g1 - 10 && b2 < r2 - 10 && b2 < g2 - 10 && b3 < r3 - 10 && b3 < g3 - 10 && b4 < r4 - 10 && b4 < g4 - 10) {
        isWhite = false;
    }

    return isBlack ? "B" : (isWhite ? "W" : "");
}

document.getElementById("scan").addEventListener("click", e => {

    let sgf = "(;FF[4]GM[1]SZ[" + gobanSize + "]";

    sgf += sgfSetup;
    sgf += ")";

    document.getElementById("result").innerText = sgf;

    const parent = document.getElementById("js-igo");
    while (parent.firstChild) {
        parent.removeChild(parent.firstChild);
    }

    const gameView = new igo.GameView(
        "js-igo",
        sgf,
        {
            ui:{bottom: ["UndoRedo"]},
            editable: false,
        }
    );    
    gameView.fitBoardSizeToWindowAndParent();

});



image.addEventListener("load",function (){
    // canvas.width = image.naturalWidth;
    // canvas.height = image.naturalHeight;

    imgScale = canvas1.width / image.naturalWidth;
    imgX = 0, imgY = 0;

    ctx1.save();
    ctx1.scale(imgScale, imgScale);
    ctx1.clearRect(0, 0, 1000, 1000);
    ctx1.drawImage(image, 0, 0);
    ctx1.restore();

    drawGrid();
});

image.src = "19x19.jpg";

canvas2.addEventListener("click", e => {
    const rect = e.target.getBoundingClientRect();

        // ブラウザ上での座標を求める
    const   viewX = e.clientX - rect.left,
            viewY = e.clientY - rect.top;

        // 表示サイズとキャンバスの実サイズの比率を求める
    const   scaleWidth =  canvas2.clientWidth / canvas2.width,
            scaleHeight =  canvas2.clientHeight / canvas2.height;

        // ブラウザ上でのクリック座標をキャンバス上に変換
    const   canvasX = Math.floor( viewX / scaleWidth ),
            canvasY = Math.floor( viewY / scaleHeight );

	const index = (canvasX * (canvasY - 1)) * 4;

  
    var imagedata = ctx1.getImageData(canvasX, canvasY, 1, 1);

    // RGBAの取得。
    var r = imagedata.data[0];
    var g = imagedata.data[1];
    var b = imagedata.data[2];
    var a = imagedata.data[3];

    console.log(r, g, b, a);
    
});

</script>

</html>

